# 아이디어
브루트 포스 알고리즘으로 풀 수 있는 문제. 물론, 다이나믹 프로그래밍으로도 풀 수 있다고는 한다.

## 문제 파악하기
설탕공장의 설탕을 배달하는 상근이가 사탕가게에 설탕을 정확하게 $N\text{kg}$을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨 있어서 $3\text{kg}$와 $5\text{kg}$ 봉지가 있고 상근이는 최대한 적은 봉지를 가지고 가려고 한다.

상근이가 정확히 $N\text{kg}$ 배달하려고 할때, 봉지를 몇 개 가지고 가야 할까?

---

입력은 다음과 같이 주어진다.
- 첫째 줄에 $N$이 주어진다. ( $3≤N≤5000$ )

출력은 상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 $N \text{kg}$을 만들 수 없다면 -1을 출력한다.

## 방법 고안
최대한 적은 봉지를 들고 간다고 했을 때 더 많은 양을 챙겨야 하는 것은 아무래도 5kg의 봉지일 것이다. 가령 30kg은 3의 배수이면서 5의 배수이기 때문에 더 큰 것으로 채우는 것이 오히려 개수가 적기 때문이다.

- 5kg으로 나누어떨어지는 경우 5kg을 계속 빼 주는 것이 가장 개수가 적을 것이다.
- 5kg으로 나누어떨어지진 않지만 3kg으로 나누어떨어지는 경우 3kg으로 계속 줄여서 무게를 채울 수 있을 것이다.
- 그 어느 쪽도 나누어떨어지지 않으면 우선 5kg을 빼 보는 것으로 한다.

예를 들어 보자.
> 15kg의 경우 : 5의 배수이므로 15-10-5-0, 3봉지
> 21kg의 경우 : 3의 배수이므로 21-18-15, 그 상황에서 5의 배수이므로 15-10-5-0, 즉 3kg 2봉지, 5kg 3봉지로 총 5봉지
> 26kg의 경우 : 5의 배수도, 3의 배수도 아니므로 우선 5부터 빼본다. 그러면 21kg이 되고, 나머지는 위와 같다. 즉 6봉지
> 7kg의 경우 : 7kg에서 5kg을 빼면 남는 2kg은 5의 배수도 3의 배수도 아니며 5보다 크지도 않으므로 불가능, -1

## 코드화
```python
n = int(input())
cnt = 0

while n > 0:
    if n % 5 == 0:
        n -= 5; cnt += 1
    elif n % 3 == 0:
        n -= 3; cnt += 1
    elif n > 5:
        n -= 5; cnt += 1
    else:
        cnt = -1
        break

print(cnt)
```

입력을 받아서, `while`문을 활용하여 계속 0이 되거나 불가능할 때까지 줄여나간다. 5의 배수이거나 3의 배수라면 해당 3kg 혹은 5kg의 설탕 봉지로 맞추고, 그렇지 않은 경우는 5kg보다 큰 경우 5kg을 빼서 계속 확인한다. 그 이하인 경우는 3kg이 아닌 경우는 어차피 만들 수 없으므로 -1로 만든다. 그리고 `cnt`를 해당 케이스별로 1씩 증가시키거나 -1로 만든 뒤에 마지막에 출력하면 된다.

## 정리
어차피 5000 이내의 범위이기 때문에 3이나 5를 줄여도 반복 횟수는 굉장히 적기 때문에 크게 문제는 없다. 시간 복잡도 상으로도.
