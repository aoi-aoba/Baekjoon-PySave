# 아이디어
소수를 아예 미리 싹 구해놓고 각 쌍을 맞춰보면 된다.

## 문제 파악하기
> **골드바흐의 추측**    
> 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.

짝수 $N$을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 $N$이 주어질 때 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션으로 본다.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 테스트 케이스 개수 $T$가 100 이하의 자연수로 주어진다.
- 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 $N$은 짝수이며 2 이상 100만 이하의 자연수이다.

각 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.

## 방법 고안
에라토스테네스의 체로 소수를 한 번에 100만 이하까지 모두 구해버리고, 두 소수의 합이 되는지 아닌지 여부만 확인하면 되겠다. 어차피 소수의 합을 구하는 것이므로 2부터 시작해서 for 문으로 $(2, n-2) (3, n-3) \cdots$처럼 나아가면 되는데, 나아갈 마지막 부분은 $(n/2, n/2)$까지가 되겠다. 그 이상은 이미 존재하는 파티션을 순서만 뒤집은 형태로 나타나게 될 것이므로 골드바흐 파티션으로 셀 필요가 없다.

## 코드화
### 내 코드 (PyPy3 - 276ms, 119308 KB)
```python
MAX_VAL = 1_000_000

def sieve(n):
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    end = int(n ** 0.5)
    for i in range(2, end + 1):
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
    return is_prime

import sys
input = sys.stdin.readline

result = []
primes = sieve(MAX_VAL)
t = int(input())

for _ in range(t):
    tar = int(input())
    cnt = sum(1 for i in range(2, tar // 2 + 1) if primes[i] and primes[tar - i])
    result.append(str(cnt))

print('\n'.join(result))
```

`sieve` 함수는 에라토스테네스의 체 알고리즘을 활용하여 소수인 경우 `True`, 아니면 `False`를 저장하게 하여 `bool` 리스트를 반환한다.

입력으로 들어오는 모든 테스트 케이스에 대해 `cnt`를 계산하는데, 적혀있는 코드를 보면
> `sum(1 ... if primes[i] and primes[tar-i])` : 만약 `for` 루프의 `i`와 찾으려고 하는 짝수에서 `i`를 뺀 수가 모두 소수라면 1을 더해준다.   
> `for i in range(2, tar // 2 + 1)` : 테스트 케이스를 2로 나눈 값까지 2부터 시작하여 for 문을 돌려서 골드바흐 파티션을 체크한다.

의 형태로 확인하여 모든 `cnt`들을 `result.append`하여 마지막에 `join`을 활용해 한 번에 출력하게 하였다. `I/O`를 불필요하게 많이 처리하지 않게 한 번에 둔 것이다.

## 정리
소수를 빠르게 구해서 그 짝만 맞춰주면 되는 간단한 문제였다.
