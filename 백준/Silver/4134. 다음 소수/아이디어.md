# 아이디어
소수를 판별하기 위해 사용하는 가장 편한 방법을, 시간 내에 빠르게 해결하기 위해서는 어떻게 해야 할까?

## 문제 파악하기
정수 $n$ ( $0 ≤ n ≤ 4 \times 10^9$ )가 주어졌을 때, $n$보다 크거나 같은 소수 중 가장 작은 소수를 찾는 프로그램을 작성하자.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 테스트 케이스의 개수가 주어진다.
- 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 $n$이 주어진다.

출력으로 각각의 테스트 케이스에 대해 $n$보다 크거나 같은 소수 중 가장 작은 소수를 한 줄에 하나씩 출력한다.

## 방법 고안
### 소수(Prime Number)
소수란 자기 자신과 1을 제외한 그 어떤 약수도 가지지 않는 수를 의미한다. 간단히 생각해보면, 어떤 자연수 $n$에 대하여 약수가 1과 $n$만 존재하는 것이므로 2부터 $n-1$까지의 수까지 $n$을 나눌 수 있는지 아닌지의 여부를 확인하면 되는 간단한 일이다. 하지만 굳이 우리가 왜 소수를 $n-1$까지 다 나눠서 확인해야 할까? 그것이 이번 문제의 중점 포인트인 것 같다.

### 소수를 찾기 위해 확인할 것은?
어떤 자연수 $n$이 합성수라면 $n = a \times b$의 형태로 나타낼 수 있다. 이때 적어도 두 수 중 하나는 $\sqrt{n}$ 이하여야 한다. 그렇지 않으면 $ab > n$이 되므로 모순이 발생한다. 따라서, 어떤 약수 $a$가 $\sqrt{n}$ 이하라면, 쌍을 이루는 다른 약수 $b$는 필연적으로 $\sqrt{n}$ 이상이다. ($a=b=\sqrt{n}$인 경우에는 두 수가 같으므로 경계값에 해당한다.) 이와 같은 이유로, 우리는 소수 판별을 위해 굳이 $n-1$까지 모든 수를 확인할 필요 없이 $\sqrt{n}$까지만 약수를 확인하면 충분하다는 것을 알 수 있다.

## 코드화
```python
import sys
input = sys.stdin.readline

def isprime(n):
	if n < 2:
		return False
	for i in range(2, int(n**0.5) + 1):
		if n % i == 0:
			return False
	return True

n = int(input())
for _ in range(n):
	t = int(input())
	while True:
		if isprime(t):
			print(t)
			break
		else:
			t += 1
```

`isprime(n)` 함수
- $n$이라는 값을 parameter로서 받아와서 2보다 작으면 소수가 아니므로 `False`를 반환
- $n ≥ 2$라면 2부터 $\sqrt{n}+1$ (`for`문은 마지막 정수 값은 돌리지 않으므로) 범위에 대해 $n$이 $i$를 약수로 가지는 지 확인, 약수로 가질 경우 `False`를 반환
- $\sqrt{n}$ 이하에 대해 약수가 없다면 소수가 맞으므로 `True` 반환

이를 활용하여 입력을 받아 $n$개의 입력에 대하여 `isprime`의 결과를 받아온 뒤 `True`라면 출력하고, 아니면 1을 더하여 계속 확인하다가 소수가 나올 때까지 반복한다.

## 정리
소수의 특성에 대해서 생각해보아야 하는 문제였다.
