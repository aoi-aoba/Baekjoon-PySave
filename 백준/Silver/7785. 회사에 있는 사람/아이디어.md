# 아이디어
추가와 제거를 모두 빠른 시간 내에 해결할 수 있어야 하는 문제

## 문제 파악하기
자유로운 출퇴근 시간을 큰 특징으로 가지는 한 회사에서 모든 사람의 출입카드 시스템의 로그를 가지고 있다. 각 직원이 원할 때 출근하고 아무때나 퇴근할 때, 로그에 어떤 사람이 회사에 들어가고 나갔는지가 기록되어 있다. 현재 회사에 있는 모든 사람을 구하는 프로그램을 작성하자.

---

입력은 다음과 같이 주어진다.
- 첫째 줄에 로그에 기록된 출입 기록 수 $N$이 $2$ 이상 $10^6$ 이하의 자연수로 주어진다.
- 다음 $N$개 줄에 출입 기록이 순서대로 주어지는데, 출입 기록은 각 사람의 이름이 주어진 뒤 `enter`나 `leave`가 주어진다.
- `enter`이 출근, `leave`가 퇴근이다.
- 회사 내에는 동명이인은 존재하지 않고, 대소문자가 다른 경우 서로 다른 사람이다. 사람들의 이름은 알파벳의 대소문자로 구성된 5글자 이하의 문자열이다.

출력으로 현재 회사에 있는 사람의 이름을 사전 역순으로 한 줄에 한 명씩 출력한다.

## 방법 고안
파이썬의 집합(set) 내에서는 내부적인 해시 테이블을 사용함을 이용하여 `enter`이냐 `leave`냐에 따라 적절히 추가 혹은 제거를 활용해주고  마지막에 `sorted`를 활용하여 정렬 후 출력하면 되는 간단한 문제이다.

## 코드화
```python
import sys
input = sys.stdin.readline

n = int(input())
dataset = set()

for _ in range(n):
    name, action = input().split()
    if action == "enter":
        dataset.add(name)
    else:
        dataset.discard(name)

for name in sorted(dataset, reverse=True):
    print(name)
```

$n$ 값을 받아서 `for` 문을 돌린 뒤, 각 줄에 대하여 `name`과 `action`의 형태로 입력을 받아 `enter`이라면 `add`를, 아니면 `discard`를 사용한다. 입력 내에 있는 사람만 `leave`가 나온다는 보장이 있을 가능서이 높지만 아닐 경우에도 안전하게 돌리기 위해 `discard`를 사용했다.

그리고 `sorted()`를 통해 정렬하되 `reverse=True`를 지정하여 사전 역순으로 정렬하고 하나씩 `for`문을 통해 출력하게 된다면 `print()`는 줄개행을 포함하기 때문에 원하는 방식으로 출력할 수 있다.



## 정리
python `set`의 내부 구조는 해시 테이블이다.

### 해시 테이블이란?
데이터를 key-value 쌍으로 저장하는 자료구조로, key를 해시 함수에 넣어서 나온 해시 값(hash value)를 기반으로 저장 위치(index)를 빠르게 계산한다. 여기에서 `set`은 value 없이 key만 저장하는 key-only의 해시 테이블로 보면 된다. 즉, `dict`에서 value를 버린 구조로 볼 수 있는데, 실제로 내부적으로는 거의 동일하게 작동한다.

```python
s = set(["a", "b", "c"])
d = {"a": True, "b": True, "c": True}
```

내부적인 해시 함수에 의하여 특정 인덱스에 저장되기 때문에 `object in set` 같은 방식으로 체크하면 해시 값을 바로 찾아서 검색하기 때문에 매우 빠른 탐색이 가능하다.

### 해시 테이블의 간략한 동작 방식
1. 삽입
삽입되는 특정 객체 혹은 변수 등의 해시 값을 계산(`hash()`)하고 이 값을 배열의 크기로 나눈 나머지를 인덱스로 사용한다. (충돌 방지를 위한 것) 그리고 해당 위치에 객체를 저장한다.

2. 검색
특정 객체 혹은 변수에 대해 `object in set` 수행 시 같은 방식으로 해시 값을 계산하고 저장 위치를 찾아서 해당 위치에 있다면 `True`를 반환한다.

3. 충돌 처리(Collision Handling)
서로 다른 값이 같은 해시 값을 가질 수 있다. 이 경우를 충돌한다고 하는데, Python은 오픈 어드레싱(open addressing) 방식으로 이를 처리하여 충돌이 발생하면 다음 빈 슬롯을 찾는다(linear probing 등)

해시 충돌이 심하면 시간 복잡도가 최악의 경우 $O(n)$까지 치닫을 수 있지만, 파이썬은 해시 함수 최적화와 리사이징(재해싱) 기능으로 이런 상황을 잘 피하게 되어 있기 때문에 평균적으로 상수 시간($O(1)$)에 삽입, 삭제, 검색이 가능하게 한다.

다만, `set` 내부에는 해시 가능한(immutable) 값만이 들어갈 수 있다. `list`나 `dict`, `set` 같은 mutable하고 해시 불가능한 값들은 넣을 수 없다.
