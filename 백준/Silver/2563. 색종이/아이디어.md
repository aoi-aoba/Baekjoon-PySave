# 아이디어
100×100 크기의 보드를 만드는 것에서 시작해보자. 금방 파악할 수 있다!

## 문제 파악하기
가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.

![](https://velog.velcdn.com/images/aoi-aoba/post/11698ae1-a504-4c92-bdfa-610455bcd54e/image.png)

예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 색종이의 수가 100 이하로 주어진다.
- 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다.
- 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다.
- 색종이는 도화지 밖으로 나가지 않는다.

## 방법 고안
2차원 배열을 활용하여 문제를 해결할 수 있다.

### 2차원 배열로 아예 색종이가 덮이는 부분을 구현하자
종이가 덮여지는 부분이면 `True`, 아니면 `False`인 2차원 배열에 대하여 사이즈를 만들고, 좌표축으로서 나타내는 것이다. 그러면,
- 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이므로 검은 사각 종이의 x좌표 최솟값
- 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이므로 검은 사각 종이의 y좌표 최솟값

그러면, 결국 10을 더한 부분까지 `True`로  배열 내 값을 바꿔주고 `True` 값을 가진 부분만 세어서 모두 더한 개수가 답이 되는 것이다. 즉, 색종이를 1×1 크기로 잘라서 격자 형태로 붙인 뒤에 센다고 생각하면 된다.

---

## 코드화
```python
board = [[False] * 100 for _ in range(100)]

n = int(input())
for _ in range(n):
    p, q = map(int, input().split())
    for i in range(p, p + 10):
        for j in range(q, q + 10):
            board[i][j] = True

res = 0
for line in board:
    res += line.count(True)

print(res)
```

`board`를 `False` 값으로 채운 100×100 형태로 바꾸고, 각 값을 받아서 p에서 10칸, q에서 10칸을 `True`로 채울 수 있게 중첩 `for` 문을 사용하여 `board[i][j] = True`로 하게 한다. 그리고 `board`를 다시 돌면서 각 줄마다 `count(True)`를 통해 세면 된다. 그 값의 합을 `res`에 저장해 출력하면 된다.

## 배운 점 & 추가로 알게 된 것
### 파이썬 리스트 복사 방식
처음에는 리스트 `board`를 만들 때,
```python
board = [[False] * 100] * 100]
```
의 형태로 구현했다. 하지만, 이것은 일반적으로 생각하는 2차원 배열 생성과 달리, 실제로는 **같은 리스트 객체 100개를 생성**&ZeroWidthSpace;하는 코드이다. 즉, `board[0]`부터 `board[99]`까지 전부 한 개의 리스트 객체를 가리키게 된다.

이는 깊은 복사(Deep Copy)와 얕은 복사(Shallow Copy)에 대한 차이로 인해 발생한다.

### 얕은 복사(Shallow Copy)
얕은 복사는 객체의 복사 간에 **객체 자체만 복사하고 내부에 있는 참조 객체는 그대로 공유**&ZeroWidthSpace;하는 방식이다. 예를 들어, 리스트 안에 리스트가 있다면 내부 리스트는 원본과 복사본이 **서로 같은 객체를 가리키게 ** 된다.

```python
a = [[0, 0], [0, 0]]
b = a[:]  # 또는 list(a) 혹은 copy.copy(a)

b[0][0] = 1

print(a)  # [[1, 0], [0, 0]] <-- a도 바뀐다!
```
이 상황에서 `b[0][0]`을 1로 바꾸려 했지만, 얕은 복사로 인해 내부 리스트가 같은 객체를 참조하여 모두 바뀌게 된다.

### 깊은 복사(Deep Copy)
깊은 복사는 얕은 복사와 달리 객체뿐만 아니라, 내부에 포함된 모든 참조 객체까지 재귀적으로 복사해서 완전히 독립적인 객체를 생성한다.

```python
import copy

a = [[0, 0], [0, 0]]
b = copy.deepcopy(a)

b[0][0] = 1

print(a)  # [[0, 0], [0, 0]] <-- a는 그대로!
```
이 상황에서 `b[0][0]`을 1로 바꾸려 하면 깊은 복사를 통해 생성된 리스트이므로 서로 완전히 독립적으로 작동하게 된다.

### 리스트 복사 과정의 해결

```python
board = [[False] * 100] * 100]
```
의 형태로 구현했던 코드는 결국 리스트 하나를 만들어 같은 리스트 객체를 얕은 복사로 100번 복사한 셈이다. 그래서 어느 한 줄을 수정하면 100줄의 전체가 영향을 받는다. 그래서 이와 유사한 방식으로 할 수 있는 것이

```python
board = [[False] * 100 for _ in range(100)]
```
`for` 문을 활용한 생성 방식이다. 이 코드는 각 반복문을 돌 때마다 새로운 리스트를 생성하는데, 결과적으로 **100개의 독립적 행**&ZeroWidthSpace;을 생성하게 된다. 즉, 이는 깊은 복사와 비슷한 효과를 줄 수 있다.
