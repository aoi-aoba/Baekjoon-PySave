# 아이디어
소수를 아예 미리 싹 구해놓고 범위 내에 있는 것만 확인하면 되겠다.

## 문제 파악하기
베르트랑 공준은 임의의 자연수 $n$에 대하여 $n$보다 크고 $2n$보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다. 이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다. 자연수 $n$이 주어질 때, $n$보다 크고 $2n$보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하자.

---

입력은 다음과 같이 주어진다:
- 입력은 여러 개의 테스트 케이스로 주어진다.
- 각 케이스는 123,456 이하의 자연수 $n$을 포함하는 한 줄로 이루어져 있다.
- 입력의 마지막에는 0이 주어진다.

출력으로 각 테스트 케이스에 대하여 $n$보다 크고 $2n$보다 작거나 같은 소수의 개수를 출력하자.

## 방법 고안
$2n$까지의 수라고 해봐야 123,456 이하의 $n$에 대하여 약 $2\times10^6$ 정도이기 때문에 에라토스테네스의 체 알고리즘을 활용하면 크게 문제 없이 소수를 구해서 해당 범위 내의 소수가 얼마나 있는지 체크하면 될 문제이다.

## 코드화
### 내 코드 (336ms, 47108 KB)
```python
MAX_VAL = 123456 * 2

def sieve(n):
    arr = [i for i in range(n + 1)]
    end = int(n ** 0.5)
    for i in range(2, end + 1):
        if arr[i] == 0:
            continue
        for j in range(i * i, n + 1, i):
            arr[j] = 0
    return set(i for i in arr[2:] if arr[i] != 0)

import sys
input = sys.stdin.readline

primes = sieve(MAX_VAL)
num = int(input())
while num != 0:
    print(sum(1 for i in range(num + 1, 2 * num + 1) if i in primes))
    num = int(input())
```

`sieve` 함수는 에라토스테네스의 체 알고리즘을 활용하여 소수들을 `set` 형태로 반환하는 함수이므로 크게 설명은 필요하지 않다.

입력을 받아서 `MAX_VAL`인 123,456의 두 배까지 소수를 구하여 받아오고, `primes`에 대하여 입력으로 들어온 테스트 케이스에 대해 `num+1`부터 `2*num`까지의 수 중에서 소수인 수를 체크한다. 이때 `set` 형태이므로 `in`을 활용하여 해시 테이블의 탐색을 활용하면 빠르게 탐색이 가능하다.

> `print(sum(1` : 1들의 합을 더해서 출력한다.   
> `for i in range(num + 1, 2 * num + 1)` : 찾을 범위인 $n$부터 $2n$을 설정해준다.   
> `if i in primes))` : `set` 자료구조의 탐색을 진행한다.

## 정리
ChatGPT에 코드 리뷰를 부탁한 결과, 리팩토링을 제시하여 그것을 반영한 코드를 작성해보았다.

### ChatGPT 리팩토링 반영 수정 코드 (268ms, 34340 KB)
```python
MAX_VAL = 123456 * 2

def sieve(n):
    is_prime = [True] * (n + 1)
    end = int(n ** 0.5)
    for i in range(2, end + 1):
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
    return is_prime

import sys
input = sys.stdin.readline

primes = sieve(MAX_VAL)

while True:
    num = int(input())
    if num == 0:
        break
    print(sum(1 for i in range(num + 1, 2 * num + 1) if primes[i]))
```

### 함수 처리 변경
달라진 부분은 우선 `sieve` 함수이다. `arr`을 활용하여 소수인지 아닌지를 0 또는 해당 인덱스의 수를 갖게 하여 체크했는데, 메모리 낭비를 줄이기 위해 소수 판별만 할 수 있도록 `bool` 배열로 수정하였다. 그렇게 하면 `is_prime[n] = False`라던가 `if is_prime[i]`와 같은 방식으로 조금 더 직관적인 코드를 편성할 수 있고, 리턴 값 역시 `is_prime`을 그대로 반환한다.

### set에 소수를 저장하지 않고 탐색
`set`은 탐색 속도가 빠르지만, 어차피 여기에서 우리는 $n$부터 $2n$의 범위라는 특정 범위를 탐색할 것이기 때문에 인덱스를 활용하여 `is_prime[i]`를 그대로 활용해 탐색하는 것이 훨씬 빠르다. 그래서 `print` 부분도 `if`문이 `if i in primes` 대신 `if is_prime[i]`로서 가독성도 높일 수 있다.

### 코드 요약
두 코드는 모두 에라토스테네스의 체를 활용하기 때문에 `sieve` 함수는 사실상 비슷하고 시간 복잡도는 $O(n \log \log n)$이다.

- 소수 판별 반식은 `arr[i] = 0` 방식에서 `is_prime[i]` 방식으로 변경했다.
- 소수 저장은 소수만 저장하는 `set` 방식에서 `bool[]` (전체 범위 저장) 방식을 택했다.
- 소수 판별은 set lookup 대신 list index를 활용하였다.

이 과정에서 입력 처리 루프는 입력이 123456일 때 최대 약 123456번 반복 가능한 것은 동일하나, 내가 작성한 코드는 `i in primes`를 이용하여 평균 시간복잡도는 $O(1)$의 상수 시간인 set lookup이고, 리팩토링 한 코드는 인덱스 조회(list index)이므로 $O(1)$의 확정적 상수 시간이다.

두 방식 모두 $O(N)$이지만, set lookup은 해시 충돌이나 내부 연산이 필요하므로 list lookup보다 비용이 크고, 단순 배열 조회인 리팩토링 코드가 더 빠르게 동작한다.

메모리 효율의 부분에서는 정수 리스트가 불리언 리스트로, 소수만 저장하는 set에서 전체를 bool로 저장하는 것으로 변화하였는데
- `range(n+1)` 정수 리스트는 `int` 리스트
- `set` of primes의 경우 약 2만 2천 개의 소수가 들어가야 하고 hash 구조로 부가 오버헤드가 발생함
- `bool[]`의 경우 파이썬은 `bool`도 객체지만 리스트는 최적화되고 $n \approx 2.5 \times 10^5$임

이에 따라 메모리 효율성도 개선 코드가 훨씬 높다.
