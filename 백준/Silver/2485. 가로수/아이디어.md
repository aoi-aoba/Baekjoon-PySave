# 아이디어
최대공약수의 아이디어를 파악해야 하는 문제

## 문제 파악하기
분수 $\frac{A}{B}$는 분자가 $A$이고 분모가 $B$인 분수이다. $A, B$가 모두 자연수라고 하자. 두 분수의 합 또한 분수로 표현할 수 있다. 두 분수가 주어졌을 때, 그 합을 기약분수의 형태로 구하는 프로그램을 작성하시오. 기약분수란 더 이상 약분되지 않는 분수를 의미한다.

---

입력은 다음과 같이 주어진다:
- 첫째 줄과 둘째 줄에 각 분수의 분자와 분모를 뜻하는 두 개의 자연수가 순서대로 주어진다.
- 입력되는 네 자연수는 모두 30000 이하이다.

출력으로 첫째 줄에 구하고자 하는 기약분수의 분자와 분모를 뜻하는 두 개의 자연수를 빈 칸을 사이에 두고 순서대로 출력한다.

## 방법 고안
예시를 생각해보면 편하다.

예제) 4개의 가로수가 [1, 3, 7, 13]에 심어진 경우
- 각각의 가로수에 대한 간격은 (2, 4, 6)
- 이들 중 다른 간격과 맞춰서 최소한으로 줄이려면 2
- 즉, [5, 9, 11]에 세 그루를 더 심으면 됨

예제) 4개의 가로수가 [2, 6, 12, 18]에 심어진 경우
- 각각의 가로수에 대한 간격은 (4, 6, 6)
- 이들 중 다른 간격과 맞춰서 최소한으로 줄이려면 2
- 즉, [4, 8, 10, 14, 16]에 다섯 그루를 더 심으면 됨

결과적으로, 각각의 가로수 간에 주어지는 간격을 조사한 다음 모든 간격에 대해서 **최대공약수** 만큼의 거리가 새로 최소한으로 나무를 심어서 맞출 수 있는 등간격이다.

## 코드화
```python
import sys
input = sys.stdin.readline

def fgcd(a, b):
	while b:
		a, b = b, a % b
	return a

n = int(input())
cnt = 0
arr = sorted([int(input()) for _ in range(n)])

sub = []
for i in range(len(arr) - 1):
	sub.append(arr[i + 1] - arr[i])

gcd = sub[0]
for i in range(1, len(sub)):
	gcd = fgcd(gcd, sub[i])

for j in sub:
	cnt += j // gcd - 1

print(cnt)
```

`fgcd(a, b)`는 유클리드 호제법을 활용하여 최대공약수를 구하는 함수이다. `n`을 입력받고 `cnt`는 심어야 하는 나무의 개수를 저장한다.

`arr`에 모든 입력을 받고, `sub`에는 각각의 나무 사이의 거리를 `for` 문을 돌려서 저장한다. 그리고 `gcd`라는 값에는 우선 가장 앞에 있는 두 나무 사이의 거리를 저장하자. 그리고, 그 뒤 인덱스부터 모든 나무의 거리에 대해서 최대공약수를 구한다.

`sub` 안에 있는 모든 나무 사이의 거리에 대해서 추가로 심을 나무에 대해서 생각해보자. 가령, 위에서 2와 6이라는 4 거리를 사이에 둔 두 나무에 대해서 최대공약수가 2라면 4에 하나만 심으면 된다. 그리고, 6이라는 거리를 사이에 둔 두 나무 6과 12 사이에는 8과 10을 심으면 된다. 즉, 거리를 최대공약수로 나눠서 1을 뺀 값 만큼 새로 나무를 심으면 된다는 방식으로 `cnt`의 값을 더해나가고 값을 출력하면 된다.

## 정리
조금만 생각해보면 최대공약수를 통해 금방 구할 수 있다.
