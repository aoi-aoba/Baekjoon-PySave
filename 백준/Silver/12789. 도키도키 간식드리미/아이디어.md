# 아이디어
그림과 문제만 잘 이해하면 단순한 구현 문제, 잘못 이해하면 한참 빙빙 돌아버릴 수 있는 문제.

## 문제 파악하기
인하대학교 학생회에서는 중간, 기말고사 때마다 시험 공부에 지친 학우들을 위해 간식을 나눠주는 간식 드리미 행사를 실시한다. 승환이는 시험 기간이 될 때마다 간식을 받을 생각에 두근두근 설레서 시험 공부에 집중을 못 한다. 이번 중간고사에서도 역시 승환이는 설레는 가슴을 안고 간식을 받기 위해 미리 공지된 장소에 시간 맞춰 도착했다. 그런데 이게 무슨 날벼락인가! 그 곳에는 이미 모든 학생들이 모여있었고, 승환이는 마지막 번호표를 받게 되었다. 설상가상으로 몇몇 양심에 털이 난 학생들이 새치기를 거듭한 끝에 대기열의 순서마저 엉망이 되고 말았다. 간식을 나눠주고 있던 인규는 학우들의 터져 나오는 불만에 번호표 순서로만 간식을 줄 수 있다고 말했다.

그제야 학생들이 순서대로 줄을 서려고 했지만 공간이 너무 협소해서 마음대로 이동할 수 없었다. 다행히도 대기열의 왼쪽에는 1열로 설 수 있는 공간이 존재하여 이 공간을 잘 이용하면 모두가 순서대로 간식을 받을 수 있을지도 모른다. 자칫 간식을 못 받게 될지도 모른다는 위기감을 느낀 승환이는 자신의 컴퓨터 알고리즘적 지식을 활용해 과연 모든 사람들이 순서대로 간식을 받을 수 있는지 확인하는 프로그램을 만들기로 했다. 만약 불가능 하다면 승환이는 이번 중간고사를 망치게 될 것 이고 가능하다면 힘을 얻어 중간고사를 잘 볼 수 있을지도 모른다.

사람들은 현재 1열로 줄을 서있고, 맨 앞의 사람만 이동이 가능하다. 인규는 번호표 순서대로만 통과할 수 있는 라인을 만들어 두었다. 이 라인과 대기열의 맨 앞 사람 사이에는 한 사람씩 1열이 들어갈 수 있는 공간이 있다. 현재 대기열의 사람들은 이 공간으로 올 수 있지만 반대는 불가능하다. 승환이를 도와 프로그램을 완성하라.

현재 간식 배부 공간을 그림으로 나타내면 다음과 같다.

![](https://velog.velcdn.com/images/aoi-aoba/post/614a71d8-9901-4e19-8471-86c70fe3b65c/image.png)

위 예제는 다음 그림과 같이 움직였을 때 모두가 순서대로 간식을 받을 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/4998398b-9f28-4f84-a7e2-9fda3324586c/image.png)


---

입력은 다음과 같이 주어진다:
- 첫째 줄에 현재 승환이 앞에 서 있는 학생 수 $N$이 1000명 이하의 자연수로 주어진다.
- 다음 줄에는 승환이 앞에 서 있는 학생들의 모든 번호표 순서가 앞에서부터 뒤 순서로 주어진다.

출력으로 승환이가 무사히 간식을 받을 수 있는 여부에 따라 `Nice` 혹은 `Sad`를 출력한다.

## 방법 고안
이것도 정말 잘 생각해보면 간단한 구현 문제임을 알 수 있다. 서 있는 곳에서 맨 앞에 있는 사람이 만약 자신의 번호가 아니면 한 명씩 설 수 있는 공간으로 이동한다.

여기에서 중요한 점은, **한 명씩 설 수 있는 공간으로 간 사람은 다시 원래 자리로 돌아올 수 없다**&ZeroWidthSpace;는 것이다. 그렇다면, 이 사람들은 그 자리로 갔을 때 나올 수 없는 구조가 되면 불가능한 경우로 칠 수밖에 없는 것이다.

그러면, 맨 앞의 사람을 항상 확인하자. 현재 몇 번이 들어가야 하는지 확인하고, 별도의 공간의 맨 앞 혹은 현재 대기열의 맨 앞에 그 번호가 있다면 들여보낸다. 하지만, 그 어느 쪽에도 없다면, 대기열에 사람이 남아있다면 별도 공간으로 맨 앞 사람을 보낸다.

그렇게 해서 대기열에 남은 사람이 없게 되었을 때 마지막으로 체크하여 한 명씩만 설 수 있는 별도 공간에 사람이 아직 남아있다면, 그 사람들이 이동할 수 없을 때는 불가능한 케이스임이 자명해진다.

## 코드화
### 내 코드 (PyPy3 - 96ms, 109544 KB)
```python
class Stack:
	def __init__(self):
		self.items = []
	def push(self, item):
		self.items.append(item)
	def pop(self):
		return self.items.pop()
	def peek(self):
		return self.items[-1] if not self.is_empty() else -1
	def is_empty(self):
		return not self.items

import sys
input = sys.stdin.readline

stack1 = Stack()
stack2 = Stack()

n = int(input())
for i in input().split()[::-1]:
	stack1.push(int(i))

now = 1
while True:
	if stack1.peek() == now:
		now += 1
		stack1.pop()
	elif stack2.peek() == now:
		now += 1
		stack2.pop()
	elif not stack1.is_empty() and stack1.peek() != now:
		stack2.push(stack1.pop())
	elif stack1.is_empty() and stack2.peek != now:
		break

print("Nice" if stack1.is_empty() and stack2.is_empty() else "Sad")
```

스택 구조를 객체로서 구현해보았다.
- `push`는 값을 넣는 것, `pop`은 맨 위에서 값을 빼는 것
- `peek`는 맨 위 값을 확인하는 것, `is_empty`는 비어있는지 확인

현재 대기열을 `stack1`, 별도 공간을 `stack2`로 하자. 어차피 맨 앞의 사람이 나갈 수 있기 때문에 후입선출(LIFO)의 스택 구조가 가장 적합하다. 그렇게 해서 입력으로 들어오는 값을 반대로 뒤집어서 현 대기열 스택에 집어넣는다. 처음 들어갈 번호는 1번이다.

- 계속 반복문을 돌리며 별도 경우에 빠져나갈 것이므로 `while True:`
- 현재 대기열의 맨 앞에 들어갈 사람이 있다면 `now`를 1 추가하고 그 사람을 `pop`하여 들여보낸다.
- 별도 공간의 맨 앞에 들어갈 사람이 있다면 `now`를 1 추가하고 그 사람을 `pop`하여 들여보낸다.
- 만약 현재 대기열이 안 비어있으면서 맨 앞 사람이 현재 들어갈 사람이 아니라면 그 사람을 `stack1`에서 `pop`하면서 `stack2`로 `push`한다.
- 만약 현 대기열이 비어있으면서 별도 공간에서도 더 이상 처리가 불가능하면 `break`한다.

그렇게 해서 양쪽이 모두 비어 있다면 `Nice`, 아니면 `Sad`이다.

## 정리
단순한 구현 문제이지만, 문제를 잘 파악해서 적절한 자료구조를 사용했어야 했다.
