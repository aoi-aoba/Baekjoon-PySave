# 아이디어
소수를 하나하나 판별해서 찾기보다, 빠르게 소수 목록을 뽑아낼 수 있는 방법은 없을까?

## 문제 파악하기
$M$ 이상 $N$ 이하의 소수를 모두 출력하는 프로그램을 작성하자.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 자연수 $M$과 $N$이 빈 칸을 사이에 두고 주어진다.
- $M$과 $N$은 100만 이하의 자연수이다.
- $M$과 $N$이라는 입력에 대해 $M$ 이상 $N$ 이하에 소수가 반드시 하나 이상 있음이 보장된다.

출력으로 한 줄에 하나씩 증가하는 순서대로 소수를 출력한다.

## 방법 고안
### 소수(Prime Number)
소수란 자기 자신과 1을 제외한 그 어떤 약수도 가지지 않는 수를 의미한다. 간단히 생각해보면, 어떤 자연수 $n$에 대하여 약수가 1과 $n$만 존재하는 것이므로 2부터 $n-1$까지의 수까지 $n$을 나눌 수 있는지 아닌지의 여부를 확인하면 되는 간단한 일이다. 그리고 정확히는 $\sqrt{n}$까지만 확인하면 된다. 하지만 우리가 굳이 왜 하나하나 수에 대해서 소수인지 아닌지를 판단해야 할까?

### 에라토스테네스의 체
탐색해야 하는 수가 많기 때문에 $N^{\frac{1}{2}}$ 방식이 옳지 않다는 것을 알아야 한다. 시간 복잡도에 문제가 너무 많기 때문이다. 그래서 에라토스테네스의 체 알고리즘을 활용하여 $M$까지의 소수를 아예 미리 다 찾아버리고, 주어진 범위 내에 소수를 빠르게 걸러내서 출력하는 전략이 필요하다.

[소수 일반 대응 판별과 에라토스테네스의 체](https://github.com/aoi-aoba/Normal-Coding-Studies/blob/main/Coding-Mathematics/Discrimination%20of%20Prime%20Numbers%20and%20Eratosthenes'%20sieve.md)

에라토스테네스의 체 알고리즘에 대한 자세한 설명은 위 링크를 참조하도록 하자.

## 코드화
```python
MAX_VAL = 1000000

def sieve(n):
	arr = [i for i in range(n + 1)]
	end = int(n ** 0.5)
	for i in range(2, end + 1):
		if arr[i] == 0:
			continue
		for j in range(i * i, n + 1, i): # i*i보다 작은 합성수 모두 이미 지워짐
			arr[j] = 0
	return [i for i in arr[2:] if arr[i]]

import sys

primes = set(sieve(MAX_VAL))
input = sys.stdin.readline

m, n = map(int, input().split())
print("\n".join(str(i) for i in range(m, n + 1) if i in primes))
```

`sieve(n)` 함수
- 소수를 구하는 방식을 에라토스테네스의 체 방식을 활용함
- `arr`을 0-based index를 활용하여 모두 만들어두고, `end`를 $\sqrt{n}$까지 두어서 2부터 $\sqrt{n}+1$에 대하여 `for`문을 돌리며 체크하는데, 해당 배열의 해당 `i` 인덱스에 대해 값이 0이라면 소수가 아니라는 것이므로 그 수에 대해서는 체크를 건너뛴다.
- 만약 그렇지 않다면 `j`를 `i*i`부터 시작하여 `n+1`까지, `i`씩 건너뛰면서 합성수들에 대해 값을 0으로 바꿔버린다.
- 마지막에 반환하는 리스트는 2부터 시작하여 해당 인덱스의 값이 0이 아닌 경우, 즉 소수인 경우만 그럴 것이므로 그들의 리스트를 그대로 `return`한다.

`primes`는 이 리스트를 받아서 `set`으로 바꿔주는데, `set`은 숫자를 찾기 위해서 `in`을 활용하면 되기 때문에 해시 기반으로 훨씬 더 빠르게 기동하기 때문이다. 그래서 우리는 `m`부터 `n+1`까지 `for`문을 돌려서 범위 내에 소수가 존재(`i in primes`)한다면 `join`을 활용하여 모두 출력해주면 된다.

## 정리
에라토스테네스의 체 시간 복잡도는 $O(n \log \log n)$이고 이 문제에서는 $n=10^6$임에 따라 소수를 구하는 데 드는 비용은 상수 시간에 가깝다고 볼 수 있겠다. 여기에서 사실상 중요한 것은 $O(k)$만큼의 시간이 리스트-집합 간 변환 시간에 걸린다는 것인데 $\pi(10^6) \approx 78498$ 정도이므로 대략 $O(10^5)$의 수준이다. 해시 기반의 원소 확인(`if i in primes`)을 하기 위한 비용으로서는 그렇게 큰 비용은 아니다.
