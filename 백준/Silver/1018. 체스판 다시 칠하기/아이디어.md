# 아이디어
가장 일반적인 형태의 브루트 포스 알고리즘

## 문제 파악하기
$M \times N$ 크기의 보드에 대해서 어떤 정사각형은 검은색으로, 나머지는 흰색으로 칠해져 있는 이 보드에 대해 이 보드를 적당히 잘라서 $8 \times 8$의 체스판으로 만들려고 한다.

체스판은 검은색과 흰색이 번갈아 칠해져야 하며, 구체적으로 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠할 수 있는 경우는 맨 왼쪽 위 칸에 대해 검은색이거나 흰색인 경우의 두 가지밖에 설명할 수 없는 것이다.

보드가 체스판처럼 칠해져 있다는 보장이 없어서, $8 \times 8$ 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠하려 한다. 당연히 그 크기는 아무데서나 잘라도 크게 문제가 없다. 정사각형을 최소한으로만 칠한다고 할 때, 몇 개의 정사각형이 최소인지 구하자.

---

입력은 다음과 같이 주어진다.
- 첫째 줄에 보드의 크기 $N$과 $M$이 8 이상 50 이하의 자연수로 주어진다.
- 둘째 줄부터 $N$개 줄에 보드의 각 행의 상태가 주어진다.
- B는 검은색이며, W는 흰색이다.

출력은 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.

## 방법 고안
전체 보드 크기가 아무리 크다고 해도 $50 \times 50$ 크기이고, 이들을 $8 \times 8$ 크기로 자른다고 생각하면 경우의 수는 $43 \times 43$개의 경우의 수가 만들어지고, 그러면 총 확인해야 할 칸의 개수는 $43^2 \times 8^2 = 118336$ 정도이므로 크게 문제가 되지 않는다. 파이썬에서는 주로 $10^6$이 $O(n)$의 1초당 범위 정도이므로 안정적으로 작동할 수 있을 것이다. 즉, 전체 보드에 대해서 만들 수 있는 모든 $8 \times 8$ 크기로 잘라서 직접 모든 경우를 확인하는 것이다. 그러고 나서 최솟값을 출력하면 끝.

여기에서 중요한 것은 시작의 칸 즉 맨 위 가장 왼쪽 칸이 검은색인지 흰색인지에 대한 것을 따지는 것이 중요하다.

### 맨 위 가장 왼쪽 칸이 검은색인 경우
> BWBWBWBW   
> WBWBWBWB   
> BWBWBWBW...

와 같은 형태로 진행되기 때문에
- 검은색의 위치를 좌표 형태로 두면 인덱스 좌표로는 $(0, 0) (0, 2) (0, 4) (0, 6) (1, 1) (1, 3) \cdots$ 와 같은 형태로 나타나므로 인덱스 좌표의 행 번호와 열 번호의 합이 짝수이다.
- 흰색의 위치를 좌표 형태로 두면 인덱스 좌표로는 $(0, 1) (0, 3) (0, 5) (0, 7) (1, 0) (1, 2) \cdots$ 와 같은 형태로 나타나므로 인덱스 좌표의 행 번호와 열 번호의 합이 홀수이다.

### 맨 위 가장 왼쪽 칸이 흰색인 경우
위의 형태가 반대로 되기 때문에, 검은색의 위치는 행 번호와 열 번호의 합이 홀수고 흰색의 위치는 행 번호와 열 번호의 합이 짝수이다.

---

이런 것들을 활용하여 각 칸에 검은색인 B가 와야 할지, 흰색인 W가 와야 할지 잘 판단해본다면 그 칸에 색을 칠해서 바꿔야 할지 칠하지 말고 바꾸지 말아야 할지에 대한 것을 체크해서 개수를 셀 수 있을 것이다.

## 코드화
```python
n, m = map(int, input().split())
board = []
res = []

for _ in range(n):
    board.append(input())

for i in range(n - 7):
    for j in range(m - 7):
        drawStartB = drawStartW = 0
        for a in range(i, i + 8):
            for b in range(j, j + 8):
                # 특정 칸의 인덱스 합이 짝수
                if (a + b) % 2 == 0:
                    # BWBW..로 시작하면 인덱스 합 짝수 위치가 B여야 함
                    if board[a][b] != 'B':
                        drawStartB += 1
                    # 반대로 WBWB로 시작하면 인덱스 합 짝수 위치는 W
                    if board[a][b] != 'W':
                        drawStartW += 1
                else:
                    if board[a][b] != 'W':
                        drawStartB += 1
                    if board[a][b] != 'B':
                        drawStartW += 1
        res.append(drawStartB)
        res.append(drawStartW)
print(min(res))
```

우선 입력을 `board`에 모두 저장하고, `i`와 `j`는 전체 크기에서 7씩 인덱스를 빼면 남은 칸부터 8칸을 셀 수 있기 때문에 모든 경우의 수를 `a`와 `b`로서 $8 \times 8$ 크기를 만든다.

- `a + b`의 값이 짝수라면
	- 왼쪽 위가 검은색일 경우 인덱스 합이 짝수인 칸이 검은색
   	- 왼쪽 위가 흰색일 경우 인덱스 합이 짝수인 칸이 흰색
- `a + b`의 값이 홀수라면
	- 왼쪽 위가 검은색인 경우 인덱스 합이 홀수인 칸이 흰색
    - 왼쪽 위가 흰색일 경우 인덱스 합이 홀수인 칸이 검은색
    
이 점에 착안해서 `drawStartB`와 `drawStartW`의 케이스별로 별대로 분리하여 값을 추가하여 맨 마지막에 결과값으로 최솟값을 출력해주면 된다.

## 정리
비교적 안전한 경험적 기준 상 파이썬의 경우 1초의 안전 기준은 초당 $10^6$ 번의 연산이 가능함에 따라 현재 상황에서는 반복 구조를 계산해보았을 때 연산 횟수가 $64(n-7)(m-7)$로 정리되므로 Big-O Notation으로 나타내면 $O(mn)$으로 정리할 수 있다. 그리고 위에서의 계산상에서 나타내었듯 약 10만 번의 계산 정도로 확인할 수 있기 때문에 충분히 브루트 포스 알고리즘으로 해결 가능함을 알 수 있다.

- `res` 리스트를 사용하기보다는 아예 `minCnt` 같은 변수를 사용해서 그때그때 최솟값을 계산해주는 것이 메모리 효율적이다.

```python
n, m = map(int, input().split())
board = []
minCnt = 0
...
		minCnt = min(minCnt, drawStartB, drawStartW)
print(minCnt)
```
