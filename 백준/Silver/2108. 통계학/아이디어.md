# 아이디어
각각의 값에 대해 어떻게 구할 것인지 방법을 잘 고안해보자. 내장 함수를 적절히 사용한다면 충분히 구할 수 있을 것!

## 문제 파악하기
수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 $N$개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, **$N$은 홀수라고 가정하자.**

- 산술평균 : $N$개의 수들의 합을 $N$으로 나눈 값
- 중앙값 : $N$개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값
- 최빈값 : $N$개의 수들 중 가장 많이 나타나는 값
- 범위 : $N$개의 수들 중 최댓값과 최솟값의 차이

$N$개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.


---

입력은 다음과 같이 주어진다:
- 첫째 줄에 수의 개수 $N$이 50만 이하로 주어진다.
- 단, $N$은 홀수로 주어진다.
- 다음 $N$개 줄에 정수들이 주어진다.
- 입력되는 정수의 절댓값은 4000을 넘지 않는다.

출력은 다음과 같이 하자:
- 첫째 줄에는 소수점 이하 첫째 자리에서 반올림한 산술평균을 출력한다.
- 둘째 줄에는 중앙값을 출력한다.
- 셋째 줄에는 최빈값을 출력하되, 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.
- 넷째 줄에는 범위를 출력한다.

## 방법 고안
각각의 통계값의 특징에 대해서 생각해보면, 적절한 함수로 접근이 가능하다.

### 산술평균
산술평균은 모든 값을 개수로 나눈 값이므로, $N$개의 합을 $N$으로 나누면 된다. 즉, `sum` 함수로 합을 구하고 값을 나누면 되는데, 이때 여기에서 출력 조건 중 **소수점 이하 첫째 자리에서 반올림**&ZeroWidthSpace;하라고 하였기 때문에 우리는 `math.ceil()` 혹은 `round()`를 사용할 수 있겠다.

### 중앙값
중앙값은 모든 값을 증가하는 순서로 나열해 중앙에 위치하는 값이다. 그렇게 나열해야 하기 때문에 `sorted` 혹은 `sort`를 활용하여 중앙 위치만 인덱스로 뽑으면 된다. 이때, $N$이 홀수라고 가정했기 때문에 중앙값은 딱 하나만 존재한다(짝수 개의 경우 두 개의 평균을 내야 하는 점에서). 그리고 그 인덱스는 $\frac{N}{2}$로 계산할 수 있다.

### 최빈값
최빈값은 일반적으로 하나하나 딕셔너리를 사용해서 구할 수도 있지만, 여기에서 찾을 때는 `collections`의 `Counter`를 사용할 수 있다. 이 부분에 대해서 조금 설명해보자.

입력으로 `5, 1, 3, 2, 2`의 5가지 수가 들어갔다고 해보자. 그러면

```python
from collections import Counter
...
counter = Counter(arr)
modes = counter.most_common(2)
```

이런 방식으로 카운터를 사용할 수 있다. iterable한 목록의 항목 수를 셀 수 있는데, 리스트/튜플/딕셔너리/문자열을 입력으로 받아 각 요소 개수가 포함된 출력을 제공한다. `counter`와 `modes`를 출력해보면,

```
Counter({2: 2, 1: 1, 3: 1, 5: 1})
[(2, 2), (1, 1)]
```

다음과 같은 출력을 받을 수 있다. 각 요소의 개수가 포함된 출력을 `counter`로 받을 수 있는데, `counter` 내에서 `most_common(val)` 메서드를 사용하면 카운터 목록에서 가장 일반적인 요소를 반환한다. 이때 `val`의 값만큼 그 개수를 출력한다.

### 범위
범위는 어차피 최댓값과 최솟값의 차를 구하면 되기 때문에 `max`와 `min`만 사용하면 된다.

## 코드화
### 내 코드 (Python 3 - 388ms, 55464 KB)
```python
import sys
from collections import Counter

input = sys.stdin.readline

n = int(input())
arr = [int(input()) for _ in range(n)]
arr.sort()

print(round(sum(arr) / n))  # 산술평균
print(arr[n // 2])          # 중앙값

counter = Counter(arr)
modes = counter.most_common(2)

if len(modes) == 1:
    print(modes[0][0])
elif modes[0][1] == modes[1][1]:
    print(modes[1][0])
else:
    print(modes[0][0])
# 최빈값

print(max(arr) - min(arr))  # 범위
```

위에서 설명한 대로 진행하면 된다.
- 모든 값은 `arr`에 `for`문을 사용하여 줄마다 입력을 받아 넣어준다.
- 산술평균은 `sum`을 통해 값을 구하고 `n`으로 나눈 값에 대하여 `round` 함수를 사용하여 반올림한다.
- 입력을 받은 뒤에 바로 `sort()`를 진행했기 때문에, 중앙값은 `[n//2]`의 인덱스로 찾으면 된다.
- 카운터를 활용하여 최빈값 두 개를 받아온다.
  - 최빈값이 하나인 경우 그냥 최빈값 하나를 출력한다. (값, 빈도) 형태이므로 [0]을 출력한다.
  - 최빈값의 빈도가 같은 경우 두 번째로 작은 것을 출력하기 위해 [1][0]을 사용한다.
  - 그 어느 쪽에도 해당하지 않는다면, 최빈값을 두 개 받아온 것이나 빈도에 차이가 있다는 것이므로 그냥 [0][0]이다.
- 범위는 최대에서 최소를 빼면 된다.
  
## 정리
`counter`에 대한 이해가 있다면 충분히 간단하게 코드를 만들 수 있는 문제였다.
