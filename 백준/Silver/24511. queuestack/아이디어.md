# 아이디어
큐스택(queuestack)이라는 이름의 자료 구조를 잘 판단해보면, 결국 그 자료구조가 무엇인지 확인할 수 있게 된다.

## 문제 파악하기
큐스택 자료구조의 구조는 다음과 같다.
- 1번, 2번, $\cdots$, $n$번의 자료구조가 나열되어 있다.
- 자료구조는 큐 또는 스택이 나열된다.
- 각각의 자료구조에는 한 개의 원소가 들어있다.

큐스택의 작동은 다음과 같다.
- $x_0$을 입력받는다.
- $x_0$을 1번 자료구조에 삽입한 뒤 1번 자료구조에서 원소를 pop한다. 그때, pop된 원소를 $x_1$이라 하자.
- $x_1$을 2번 자료구조에 삽입한 뒤 2번 자료구조에서 원소를 pop한다. 그때, pop된 원소를 $x_2$이라 하자.

그 과정을 반복하고,
- $x_{n-1}$을 $n$번 자료구조에 삽입한 뒤 $n$번 자료구조에서 원소를 pop한다. 그때, pop된 원소를 $x_n$이라 하자.

이렇게 나온 원소 $x_n$을 리턴한다. 길이 $M$의 수열 $C$를 가져와서 수열의 원소를 앞에서부터 차례대로 큐스택에 삽입하자. 이전에 삽입한 결과는 남아 있다. 

큐스택에 넣을 원소들이 주어졌을 때, 해당 원소를 넣은 리턴값을 출력하는 프로그램을 작성하자.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 큐스택 구성 자료구조 개수 $N$이 10만 이하의 자연수로 주어진다.
- 둘째 줄에 $N$ 길이의 수열 $A$가 주어지고, $A_i$는 큐라면 0, 스택이라면 1로 주어진다.
- 셋째 줄에 $N$ 길이의 수열 $B$가 주어지고, $B_i$는 10억 이하의 자연수로서 $i$번 자료구조에 들어있는 원소이다.
- 넷째 줄에 삽입할 수열 길이 $M$이 10만 이하의 자연수로 주어진다.
- 다섯번째 줄에 큐스택에 삽입할 원소를 담고 있는 길이 $M$의 수열 $C$가 주어지며, $C_i$는 10억 이하의 자연수이다.

출력으로 수열 $C$ 원소를 차례대로 큐스택에 삽입했을 때의 리턴값을 공백으로 구분하여 출력한다.

## 방법 고안
### 큐와 스택을 다시 복기해보자
스택(Stack) 구조는 후입선출(Last in, First Out) 구조이다. 나중에 들어간 것이 항상 먼저 pop되는 구조이다. 즉, 만약 큐스택에서 스택 부분이 있다면, 들어가는 원소가 다시 pop 되는 것을 생각해볼 수 있다.

큐(Queue) 구조는 선입선출(First in, First Out) 구조이다. 나중에 들어간 것은 들어가고, 먼저 들어갔던 것이 pop 되는 구조이다. 즉, 만약 큐스택에서 큐 부분이 있다면 안에 있던 원소가 pop 되고 들어가는 원소가 그 자리에 차지하게 되는 것을 생각해볼 수 있다.

### 예시를 확인해보자
예시 1번 정도만 확인해보자.

- 큐스택의 구조는 [0, 1, 1, 0] 이므로 [큐, 스택, 스택, 큐] 형태이다.
- 초기값은 [1, 2, 3, 4]가 저장되어 있다.

그러면 여기에서 생각해볼 것은 '큐'는 안에 값이 들어가면서 바뀌고, 스택은 안에 값이 들어갔다가 바로 pop 되는 값과 같다. 그러니까, 스택은 무시하고 큐만 보자.

- 큐스택의 스택을 제거하면 [1, 4]이다.
- 삽입할 수열 $C$는 [2, 4, 7]이다.

이러면, 하나하나 값을 넣어보자.
- 2를 넣으면, 1과 바뀌어 [2, 4]가 되고 1이 나온다. 그리고, 1이 들어가며 [2, 1]이 되고 4가 나온다.
- 4를 넣으면, [4, 1]이 되었다가 [4, 2]가 되며 1이 나온다.
- 7을 넣으면, [7, 2]가 되었다가 [7, 4]가 되며 2가 나온다.

결국 큐스택 전체는, 큐만 참고하여 값이 삽입되고 밀려서 나오는 구조이다. 즉, 큐만 참고한 큐 구조와 다르지 않은 것이다. 그도 그럴 것이...
- [1, 4] -> 2를 넣으면 [2, 1, 4]에서 4 추출, [2, 1]
- [2, 1] -> 4를 넣으면 [4, 2, 1]에서 1 추출, [4, 2]
- [4, 2] -> 7을 넣으면 [7, 4, 2]에서 2 추출, [7, 4]

결국 선입선출식 큐 구조와 유사함을 알 수 있다.


## 코드화
### 내 코드 (Python 3 - 204ms, 149204 KB)
```python
import sys
from collections import deque
input = sys.stdin.readline

n = int(input())
form = input().split()
values = input().split()
qs = deque([int(values[i]) for i in range(n) if form[i] == '0'])

m = int(input())
inputs = list(map(int, input().split()))
res = []

for item in inputs:
	qs.appendleft(item)
	res.append(qs.pop())

print(*res)
```

`collections`의 `deque`를 `import`하여 사용하였다.

- `form`은 큐인지 스택인지 여부를 받는 입력이고, `values`는 큐나 스택에 들어가 있는 원소를 받는 입력이다.
- 큐스택 `qs`에 대하여 `deque()`를 최초에 지정할 때, 큐 구조인 것(`form[i] === '0'`)만 돌며 `value[i]`의 값을 `int` 형으로 저장한다.

그러면 이제 큐스택은 만들어진 것이고, `m`개의 추가 입력을 받아서 리스트로 만든다.

- `inputs` 입력을 돌면서 큐스택에 값을 넣고 빼는 것을 반복한다.
- `appendleft`를 통하여 값을 넣고, `pop`하여 `res`에 추가한다.

> 위에서 설명한 대로,   
> [1, 4] -> 2를 넣으면 [2, 1, 4]에서 4 추출, [2, 1]   
> 이 구조를 직접 생각해보면 `appendleft`가 맞다는 것을 알 수 있다. `pop`은 오른쪽에서 나갈 것이다!

그리고 나머지는 값을 공백 구분하여 출력하기만 하면 되니까, `print(*res)`면 충분하다.

## 정리
큐와 스택이 각각 선입선출, 후입선출 구조임을 알고 그 구조를 파악해서 간단히 나타내지 않으면 문제상의 조건에 의해 시간 초과가 발생하기 좋은 문제였다. 문제를 완전히 구현만 하지 말고 생각을 먼저 해보는 습관을 들이자!
