# 아이디어
복잡한 조건의 정렬을 할 때는, `key=`를 `lambda`로 설정하여 적절히 원하는 대로 정렬할 수 있어야 한다.

## 문제 파악하기
화은이는 이번 영어 시험에서 틀린 문제를 바탕으로 영어 단어 암기를 하려고 한다. 그 과정에서 효율적으로 영어 단어를 외우기 위해 영어 단어장을 만들려 하고 있다. 화은이가 만들고자 하는 단어장의 단어 순서는 다음과 같은 우선순위를 차례로 적용하여 만들어진다.

1. 자주 나오는 단어일수록 앞에 배치한다.
2. 해당 단어의 길이가 길수록 앞에 배치한다.
3. 알파벳 사전 순으로 앞에 있는 단어일수록 앞에 배치한다
 
$M$보다 짧은 길이의 단어의 경우 읽는 것만으로도 외울 수 있기 때문에 길이가 $M$ 이상인 단어들만 외운다고 한다. 화은이가 괴로운 영단어 암기를 효율적으로 할 수 있도록 단어장을 만들어 주자.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에는 영어 지문에 나오는 단어 개수 $N$과 외울 단어 길이 기준이 되는 $M$이 공백으로 구분되어 주어진다.
- $N$은 10만 이하, $M$은 10 이하의 자연수이다.
- 둘째 줄부터 $N+1$번째 줄까지 외울 단어를 입력받는다.
- 입력은 알파벳 소문자로만 주어지며 단어 길이는 10을 넘지 않는다.
- 단어장에 단어가 반드시 1개 이상 존재하는 입력만 주어진다.

출력은 화은이의 단어장에 들어 있는 단어를 단어장의 앞에 위치한 단어부터 한 줄에 한 단어씩 순서대로 출력하다.

## 방법 고안
입력을 받아올 때 적절히 길이에 맞춰서 한 번에 저장해두고, 그걸 정렬만 잘 해주면 된다.

### 단어의 빈도수
단어의 빈도수 정렬이나 개수 업데이트를 위해서 딕셔너리를 사용하는 것이 일반적으로 좋게 판단된다. 어차피 개수의 파악도 필요하고, 평균적으로 단어를 찾고 업데이트하는데 있어 $O(1)$의 시간이 걸리기 때문에 효율적이다.

### 복잡한 정렬
복잡한 정렬 케이스에서는 `Python`의 `key` 튜플을 활용하자. `sorted` 함수에서는 `key=lambda`로 설정하고 적절한 튜플을 활용하여 로직을 짜서 정렬할 수 있는데, 여기에서는 특히 그것을 사용하는 것이 좋다.


## 코드화
### 내 코드 (Python 3 - 384ms, 133888 KB)
```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
wordDict = {}

for _ in range(n):
    word = input().rstrip()
    if len(word) >= m:
        if word in wordDict:
            wordDict[word] += 1
        else:
            wordDict[word] = 1

print("\n".join(sorted(wordDict, key=lambda w : (-wordDict[w], -len(w), w))))
```

`wordDict`를 딕셔너리로 설정하여, `for`문으로 각 줄에 대해 입력을 받으면서 그 단어가 `m`의 길이 이상이면 내부 분기문을 체크한다.
- 만약 단어가 존재한다면, 해당 단어의 빈도를 1 추가한다.
- 단어가 존재하지 않는다면 빈도 1로 하여 딕셔너리에 추가한다.

모든 딕셔너리가 완료된다면, `sorted`로 정렬한다. 이때 조건을 다시 복기해보자면
- 첫 번째 조건 : 자주 나오는 단어일수록 앞으로 배치
  - 자주 나온다는 빈도수는 딕셔너리이므로 `wordDict[key]`의 형태로 받아올 수 있다.
  - 빈도수가 크면 앞에 있어야 하기 때문에 내림차순, 즉 `-`를 붙여서 내림차순 조건으로 한다.
- 두 번째 조건 : 단어의 길이가 길수록 앞으로 배치
  - 길이가 길어야 한다는 것은 `len(key)`의 형태로 찾을 수 있다.
  - 이 값이 클 수록 앞에 있으려면 내림차순이므로 이 조건 역시 `-`를 붙여야 한다.
- 세 번째 조건 : 알파벳 사전 순으로 앞일수록 앞에 배치
  - 알파벳 순서는 그냥 그 값을 기준으로 하므로 `key`
  - 오름차순 조건이므로 그냥 두면 된다.

이 모든 조건에 의하여 `lambda w : (-wordDict[w], -len(w), w)`의 튜플로서 로직을 만들 수 있다.
  
## 정리
`sorted` 혹은 `sort`를 할 때 적절한 `lambda`를 설정하여 원하는 대로 정렬할 수 있게 하도록 하는 것이 중요하다.
