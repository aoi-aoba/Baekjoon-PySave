# 아이디어
브루트 포스 알고리즘으로 풀 수 있는 문제. 물론... 범위가 생각보다 있는 편이라, 시간이 짧다고는 보장하지 못한다.

## 문제 파악하기
종말의 수란 어떤 숙에 6이 적어도 3개 이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 수는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, $\cdots$과 같이 진행되므로 $N$번째 종말의 수를 찾으려고 한다.

---

입력은 다음과 같이 주어진다.
- 첫째 줄에 $N$이 주어진다.
- $N$은 10000보다 작거나 같은 자연수이다.

출력은 $N$번째 종말의 수를 출력한다.

## 방법 고안
잘 생각해서 나열해보는 것이 좋다. 666, 1666, 2666, 3666, 4666, 5666까지는 그럴 수 있다고 해도 그 다음은 6666이 아니다. 666을 앞으로 붙이고, 6660, 6661, 6662, 6663과 같이 진행되다가 넘어가기 때문에 일반적인 규칙으로 (앞의 수를 1씩 늘린다) + 666 같은 구조로는 풀 수 없다. 그래서 이 문제가 아마 브루트 포스 알고리즘으로 풀 수 있는 문제인 것 같다.

10000번째 수는 2666799이기 때문에 아무리 길어도 저 수 정도까지만 확인해보면서 몇 번째 종말의 수로 나온 것인지만 체크하면 되기 때문에 python에서의 초당 연산 횟수 기준이 약 1천만 번 정도로 타이트하게 잡을 수 있다는 걸 감안하면 충분히 2초 안에 가능한 것이라고 볼 수 있다.

## 코드화
```python
n = int(input())
num = 666
idx = 1
while idx != n:
    num += 1
    if str(num).count("666") > 0:
        idx += 1
print(num)
```

입력을 받아서, 666을 기준으로 첫 번째 `idx`로 치고, 1씩 더해서 계속 추가해가면서 `666`이 포함되어 있는 경우 `idx`의 값을 1씩 늘려나간다. 그리고 그 값이 `n`과 같아지면 `while`문을 벗어나서 해당 수를 출력한다.

## 정리
비교적 안전한 경험적 기준 상 파이썬의 경우 1초의 안전 기준은 초당 $10^7$ 번의 연산이 가능함에 따라 현재 상황에서 완전 탐색을 고려하는 것도 나쁘지 않은 선택이다.
