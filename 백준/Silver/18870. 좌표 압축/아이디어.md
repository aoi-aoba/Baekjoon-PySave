# 아이디어
stable sort의 특징을 이용하여 풀 수 있는 문제. 정렬 규칙을 적절하게 설정하여 필요한 정렬만 해내는 것이 중요하다.

## 문제 파악하기
수직선 위에 $N$개의 좌표 $X_1, X_2, \cdots, X_N$이 있을 때, 이 좌표들에 대해 좌표 압축을 적용하려고 한다. $X_i$를 좌표 압축한 결과 $X\prime_i$의 값은 $X_i > X_j$를 만족하는 서로 다른 좌표 $X_j$의 개수와 같아야 한다. 압축을 적용한 결과를 출력해보자.

---

입력은 다음과 같이 주어진다.
- 첫째 줄에 $N$이 주어진다. $N$은 100만 이하의 자연수이다.
- 둘째 줄에 공백 한 칸으로 구분된 $X_1, X_2, \cdots, X_N$이 주어진다. 각각의 $X_i$는 절댓값이 $10^9$ 이하인 정수이다.

출력으로 첫째 줄에 좌표 압축을 적용한 결과를 공백 한 칸으로 구분하여 출력하자.

## 방법 고안
예시를 조금 지켜보고 생각해보면 바로 결론이 나온다. 파이썬의 내장 함수를 적절히 사용하자.

### 좌표 압축의 원리
예제 입력 1을 기준으로 하였을 때
```
5
2 4 -10 4 -9
```

문제의 설명이 조금 복잡하게 되었지만, 결과적으로 저 좌표를 각각 수직선 위의 점이라 생각하면 표시는

```
<----- -10 -9 ----------------------- 2 --- 4 ------>
```

같은 형태로 나타날 것이다. 그러면, 이걸 좌표 압축하면 가장 왼쪽에 있는 값을 0으로 둘 때, -10은 0, -9는 1, 2는 2, 4는 3이 된다. 그리고 그걸 그대로 적용하면

```
2 3 0 2 1
```

이라는 결과가 나오게 된다. 즉, 초기에 주어지는 정보를 중복을 제거한 뒤 정렬한 상태로 작은 것부터 0이라는 값으로 지정하여 대체하면 된다.

### 파이썬의 enumerate 함수와 dictionary
대략 저런 상황이 되었다면, 우선 어떤 방식으로든 정렬을 해서 중복을 제거한 리스트가 있다고 해보자. 그때, `index` 같은 방식으로 접근하게 하면 사실상 중첩 for 문으로 찾는 것과 다를 게 없다. 그렇기 때문에 파이썬의 `enumerate` 함수를 사용하면 좋다. 그리고, `dictionary`로 접근하게 한다면 해당 값이 어떤 값으로 대체되면 좋을지 찾는 시간을 빠르게 줄일 수 있다.

## 코드화
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

sortArr = sorted(set(arr))
rank = {value : idx for idx, value in enumerate(sortArr)}
print(" ".join(str(rank[x]) for x in arr))
```

빠른 입력 처리를 위해 `sys`를 사용하여 값을 받아오고, `arr`을 `set`으로 두어 중복을 제거한 다음 `sorted`로 정렬한 값을 `sortArr`에 별도로 저장한다.

즉, 위에서의 예시 같은  경우는
```python
arr = [ 2, 4, -10, 4, -9 ]
sortArr = [ -10, -9, 2, 4 ]
```
이와 같이 정렬된다. 이때 우리는 이것을 `enumerate(sortArr)`로 바꾸면 인덱스-값 쌍을 생성하여
```
(0, -10), (1, -9), (2, 2), (3, 4)
```
의 형태로 변형, 이 상황에서 `rank`를 각각 `value:idx`의 형태로 매핑 딕셔너리를 만든다. 즉
```
{-10:0, -9:1, 2:2, 4:3}
```
의 매핑 딕셔너리가 만들어진다. 이때, `print()` 안족에서 접근할 때 `arr`의 값을 `x`로 하나씩 꺼내어 `rank[key]` 형태로 접근해 인덱스 값을 받아와 `join`을 활용해 출력하는 것이다.

## 정리
`enumerate` 함수는 인덱스와 원소로 이루어진 튜플을 만들어준다. 파이썬에서 `for` 문은 내부적으로 `in` 뒤에 오는 목록을 대상으로 계속해서 `next()` 함수를 호출하고 있다고 볼 수 있다.

```python
>>> iter_letters = iter(['A', 'B', 'C'])
>>> next(iter_letters)
'A'
>>> next(iter_letters)
'B'
>>> next(iter_letters)
'C'
````

이에 따라, 인자로 넘어온 목록을 기준으로 인덱스와 원소를 차례대로 접근하게 하는 반복자(iterator) 객체를 반환해주는 함수인 셈이다. 그래서

```python
>>> enumerate_letters = enumerate(['A', 'B', 'C'])
>>> next(enumerate_letters)
(0, 'A')
>>> next(enumerate_letters)
(1, 'B')
>>> next(enumerate_letters)
(2, 'C')
```

와 같이 작동하는 것을 볼 수 있고, 궁극적으로 `enumerate` 함수를 반환해보면

```python
>>> list(enumerate(['A', 'B', 'C']))
[(0, 'A'), (1, 'B'), (2, 'C')]
```

와 같음을 알 수 있다.
