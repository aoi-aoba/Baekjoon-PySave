# 아이디어
재귀 문제의 가장 유명한 '하노이 탑'에 대해 순서를 직접 출력하는 문제이다.

## 문제 파악하기

![](https://velog.velcdn.com/images/aoi-aoba/post/a996d1ac-9a7f-43b6-8430-65f5e3a4c666/image.png)

세 개의 막대가 있고, 첫 번째 막대에는 반경이 서로 다른 $n$개 원판이 큰 순서대로 쌓여 있다.
- 한 번에 한 개의 원판을 다른 탑으로 옳길 수 있다.
- 쌓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.

이 작업의 수행에 있어 필요한 이동 순서를 출력하자. 단, 이동 횟수는 최소가 되어야 한다.

---

입력으로 첫째 줄에 첫 번째 막대에 쌓인 원판 개수 $N$이 20 이하의 자연수로 주어진다.

출력은 다음과 같이 한다:
- 첫째 줄에 옮긴 횟수 $K$를 출력한다.
- 두 번째 줄부터 수행 과정을 출력하는데, $K$개 줄에 걸쳐서 두 정수 $A$ $B$를 빈칸을 사이에 두고 출력한다.
- $A$ $B$라는 말은 $A$번째 탑 맨 위 원판을 $B$번째 탑 맨 위로 옮긴다는 의미이다.

## 방법 고안
하노이 탑의 가장 기본이 되는 문제인데, 하노이 탑 알고리즘이 가장 대표적인 재귀 문제이다.

### 하노이 탑 최소 횟수의 아이디어 이끌어내기
우선, 몇 개의 탑을 직접 옮겨보자. 첫 번째로, $N=1$의 경우이다. 한 개의 원판은, 직접 맨 마지막으로 옮길 수 있다. 한 번이면 충분하다.

![](https://velog.velcdn.com/images/aoi-aoba/post/0a3010b3-630f-4792-8693-f54c4478c7e5/image.png)

두 개의 원판은 어떨까? 가장 큰 원판이 3번으로 옮겨가기 위해서, 위에 있는 원판을 중간에 있는 2번으로 먼저 옮겨야 한다. 즉, 작은 원판이 1-2로 움직이면, 그때 큰 원판이 1-3으로 움직이고, 그 위에 2-3으로 작은 원판을 옮기면 된다. 세 번이면 충분하다.

![](https://velog.velcdn.com/images/aoi-aoba/post/60f131e9-b083-4109-b2a7-6ed7df334414/image.png)

세 개의 원판은 어떨까? 가장 큰 원판이 3번으로 옮겨가기 위해서, 위에 있는 두 개의 원판을 2번으로 옮겨야 한다. 두 개의 원판이 2번으로 가기 위해서는, 맨 위의 원판이 3번으로 옮겨가야 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/10e57c00-618b-43cc-b46c-d5c724aad1a5/image.png)

즉, $N$개의 원판을 3번으로 옮기려면, 가장 아래 큰 원판을 제외한 $N-1$개의 원판을 중간 경유 위치로 옮겨야 한다. 1에서 3으로 갈 때는 중간 경유지가 1일 것이고, 중간 경유지인 2번에 모두 쌓여 있는 경우 2에서 3으로 가기 위해 중간 경유지는 1일 것이다.

위 그림에서 첫 번째 회색 네모 부분은 중간 경유지가 2인 경우 $N-1$개의 원판을 옮긴 것이고, 두 번째 회색 네모 부분은 중간 경유지가 1인 경우 $N-1$개의 원판을 옮긴 것이다.

### 재귀의 아이디어
$N$개의 원판이 있을 때, $N-1$개의 원판은 '목적지(dest)'가 아닌 '경유지(by)'로 보낸다고 생각하자. 그 경유지는 1번 혹은 2번이 될 수 있다. 그렇다면, 재귀로서 표현할 수 있다.
```
hanoi(원판 수, 시작위치, 경유위치, 도착위치)
	if 원판 수가 1이라면:
    	원판을 시작위치에서 도착위치로 옮긴다
    else:
   		맨 밑 원판을 제외한 원판을 경유위치로 모두 옮긴다
        맨 밑 원판을 시작위치에서 도착위치로 옮긴다
        경유위치의 원판들을 도착위치로 모두 옮긴다
```

같은 형태로 재귀 함수로서 구현이 가능해질 것이다.

### 이동하는 횟수?
이동 횟수는 사실상 수학적으로 뽑아낼 수 있다.

- 1개의 원판을 옮길 때는 직접 옮길 수 있다. 즉, $a_1 = 1$
- 2개의 원판을 옮길 때, $N-1$개의 원판, 즉 1개의 원판을 경유지로 보냈다가 다시 도착지로 보내야 한다. $a_2 = 2a_1 + 1 = 3$
- 3개의 원판을 옮길 때도 마찬가지이다. 다만, 2개의 원판이 경유지로 가야 한다는 점에서 $a_3 = 2a_2 + 1 = 7$이 된다.

즉, $N$개의 원판을 옮기려면 $a_1 = 1$이면서 $a_n = 2a_{n-1} + 1$인 $a_n$의 점화식이 만들어진다.

$a_n + 1 = 2a_{n-1} + 2$라고 변형하면, $a_n + 1 = 2(a_{n-1} + 1)$의 형태로 바꿀 수 있고, $a_n + 1 = b_n$으로 두면 $b_n = 2b_{n-1}$이 된다. 이는 초항이 $b_1 = a_1 + 1 = 2$이면서 공비가 $2$인 등비수열이 된다.

따라서, $b_n$의 일반항은 $2 \cdot 2^{n-1} = 2^n$이라고 정리된다. 이때, 우리가 원하는 것은 $a_n$이었고, 위의 식에서 다시 $a_n = b_n - 1 = 2^n - 1$이라고 정리할 수 있다.

결과적으로 우리는 하노이 탑의 최소 횟수는 $n$개의 원판에 대하여 $2^n-1$회라고 표현할 수 있겠다.

---

## 코드화
### 하노이 탑 알고리즘을 위한 함수 hanoi
```python
def hanoi(n, start, via, dest):
    if n == 1:
        moves.append(str(start) + " " + str(dest))
    else:
        hanoi(n - 1, start, dest, via)
        moves.append(str(start) + " " + str(dest))
        hanoi(n - 1, via, start, dest)
```
위에서 설명한 대로 직접 메소드로 옮긴 것이다. `hanoi()` 메소드는 `n`개의 원판과 시작점 `start`, 경유지 `via`, 도착점 `dest`를 받는다.
- 원판이 한 개라면, 시작점 `start`에서 도착점 `dest`로 바로 옮긴다.
- 그렇지 않다면, $N-1$개의 원판을 우선 `start`에서 `by`로 옮겨야 한다. 그렇다면 두 곳을 제외한 `dest`가 '경유지'가 된다.
- 재귀적으로 모든 $N-1$개의 원판을 옮겼다면, 마지막 남은 큰 원판을 `start`에서 `dest`로 옮긴다.
- 그러고 나면, 다시 $N-1$개의 원판이 경유지에 있던 것을 다시 도착점으로 옮겨야 한다. 즉, `by`에서 `dest`로 옮겨야 하므로 경유지는 `start`이다.

실제로 움직이는 것은 `moves`에 `append`하는 방식을 채택하여 이들을 한 번에 출력하는 것으로 하였다.

### 전체적인 코드
```python
import sys

def hanoi(n, start, via, dest):
    if n == 1:
        moves.append(str(start) + " " + str(dest))
    else:
        hanoi(n - 1, start, dest, via)
        moves.append(str(start) + " " + str(dest))
        hanoi(n - 1, via, start, dest)

n = int(sys.stdin.readline())
print(2 ** n - 1)
moves = []
hanoi(n, 1, 2, 3)
sys.stdout.write("\n".join(moves))
```
`hanoi()` 함수가 하노이 탑 알고리즘을 통해 모두 이동 경로를 출력해줄 것이므로 나머지는 원판 개수를 받아 `hanoi()` 함수를 호출하는 것밖에 없다. 1번에서 3번으로 이동하고, 2번을 경유한다는 최초의 상태를 보낸다. 출력은 `join`을 활용하여 한 번에 모두 출력하게 한다.

'방법 고안-이동하는 횟수?' 부분에서 말했듯 $2^n-1$의 식으로 이동 횟수는 바로 출력 가능하다. 물론, 이동할 때마다 `cnt++` 같은 방식으로 전역 변수를 추가하는 방식으로 출력해도 되지만, 굳이 그럴 필요는 없어 보인다.


## 정리
재귀에 대하여 자주 나오는 설명 예시 중 하나가 하노이 탑이다. 종료조건과 재귀 호출 부분을 잘 구성하는 것이 중요한데, 여기에서는 특히 문제가 $N = 20$의 원판까지 주어질 수 있기 때문에 입출력 처리를 잘 하는 것과 불필요한 계산을 하지 않게 하는 것도 매우 중요하다. 시간 초과가 날 수 있다!
