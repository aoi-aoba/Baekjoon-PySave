# 아이디어
백트래킹을 활용하여 스도쿠를 푸는 문제. 아이디어만 제대로 구현한다면, 사실상 어렵지 않은 구현 문제와 다름없다.

## 문제 파악하기

스도쿠는 18세기 스위스 수학자가 만든 '라틴 사각형'이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/bce0156a-9080-42e9-a360-5d5ccfd166ad/image.png)

나머지 빈 칸을 채우는 방식은 다음과 같다.

각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/bab725b3-7696-4195-8294-7a6b1b2f4425/image.png)

또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/bcc7726f-bf05-449d-82ec-ce311a6aa6a6/image.png)

이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/a0ff4eee-849a-4e81-9a53-39399cc25f6c/image.png)

게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.

---

입력은 다음과 같이 주어진다:
- 아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다.
- 스도쿠 판의 빈 칸의 경우에는 0이 주어진다.
- 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.

출력은 다음과 같이 한다:
- 모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.
- 스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.

## 방법 고안
스도쿠 규칙을 기반으로 하여 제대로 체크할 수만 있다면 백트래킹으로 풀어버리면 되는 아주 간단한 방식이다.

### 스도쿠 규칙을 통한 칸의 체크
빈 칸을 각각 1~9의 숫자를 넣어보면서, 그 칸을 그렇게 채웠을 때 문제가 생기는지 아닌지를 체크하여 백트래킹을 하기 위해서는 칸의 유효성 검사를 제대로 하는 것이 중요하다. 체크해야 하는 것은 세 가지이다.
- 해당 열에 대하여 1~9가 중복되지 않고 하나씩 숫자가 존재하는지 여부
- 해당 행에 대하여 1~9가 중복되지 않고 하나씩 숫자가 존재하는지 여부
- 해당 칸을 포함하는, 전체 스도쿠 판을 9칸씩 나눴을 때의 3×3 크기 정사각형에 1~9가 중복되지 않고 하나씩 숫자가 존재하는지 여부

이것을 하나의 함수로서 체크하여, 유효성 검사를 반복하면서 만약 이 경우에 유효하지 않은 경우라면 다른 숫자를 넣어보거나, 9까지 확인해봤는데도 유효하지 않다면 이전에 채웠던 칸을 다시 돌아가서 체크하는 방식으로 진행한다.

### 빈칸을 채워나가는 방식의 운용
물론 왼쪽 위 칸부터 체크하면서 빈칸인지 아닌지 본 다음, 빈칸이라면 진행해도 될 것이지만 굳이 그렇게까지 할 필요는 없어보이기 때문에 아예 맨 처음에 전처리로서 전체 칸을 보면서 값이 0인 칸을 따로 정리하고 이들에 대해 튜플로서 가지고 있으면서 하나씩 그 튜플 값을 꺼내서 처리하는 방식을 택한다면 효율적으로 빈칸을 돌 수 있을 것이다.

---

## 코드화
### 입력 전처리 과정
```python
import sys
SIZE = 9
BOX_SIZE = 3

board = [list(map(int, sys.stdin.readline().split())) for _ in range(SIZE)]
cellToSee = [(i, j) for i in range(SIZE) for j in range(SIZE) if board[i][j] == 0]

sudoku(0)
```
전체 칸의 크기인 9를 편의상 `SIZE`라고 두었고, 체크해야 하는 정사각형의 한 변의 길이 3을 편의상 `BOX_SIZE`로 두었다. 이 상태에서 전처리를 진행하는데, 입력은 어차피 한 줄에 9개 칸에 대한 정보가 공백을 사이에 두고 주어지므로 `list`와 `map`을 사용한다면 금방 처리가 가능하다.

그리고 위에서 설명했듯 빈칸의 전처리를 위해서 `cellToSee` 리스트를 사용하는데, 여기에서 `for` 문을 두 번 사용하여 전체 칸을 돌면서 `board[i][j]`의 값이 0이라면 `(i, j)` 형태의 튜플로 이 칸들을 저장하게 한다.

마지막에 `sudoku(0)`의 형태로 주 함수를 호출한다.

### 주요 로직 sudoku(n)
```python
def sudoku(n):
    if n == len(cellToSee):
        print('\n'.join(' '.join(str(j) for j in board[i]) for i in range(9)))
        exit()
    for check_num in range(1, 10):
        row, col = cellToSee[n]
        if check(row, col, check_num):
            board[row][col] = check_num
            sudoku(n + 1)
            board[row][col] = 0
```
$n$이라는 값을 0으로 시작하여 한 개의 빈칸을 채울 때마다 $n$을 늘리는 방식으로 `sudoku`를 호출할 것이기 때문에 처음에 종료조건으로서 `len(cellToSee)`와 같다면 전체 보드를 출력하게 하고 `exit()`를 활용하여 종료하게 만든다.

`for` 문에서 1~9의 자연수를 `check_num`으로 하여 인덱스를 돌면서, `n`에 따라 0이 저장되어 있는 `cellToSee` 내부의 튜플 좌표를 가져와  각각 `row`, `col`에 저장하여 이들에 대해 `check()` 함수로 넘겨서 유효성 검사를 진행한다.

유효하다면, 해당 칸을 `check_num`으로 등록하여 `board`를 채우고, `sudoku`를 `n+1`로 다시 호출한다. 위에서 설명했듯 이때 `n`이라는 것은 몇 개의 칸을 채웠냐는 의미이기 때문에, 백트래킹을 위해 `board[row][col]`을 0으로 돌려주는 것도 잊지 말자. `n+1`을 거치면서 모든 빈칸을 채우면 상단의 if문에 의해 종료된다.

### 유효성 검사를 위한 check(row, col, num)
```python
def check(row, col, num):
    for cellIdx in range(SIZE):
        if board[row][cellIdx] == num or board[cellIdx][col] == num:
            return False
    for r in range(BOX_SIZE):
        for c in range(BOX_SIZE):
            if num == board[row // BOX_SIZE * BOX_SIZE + r][col // BOX_SIZE * BOX_SIZE + c]:
                return False
    return True
```

첫 번째 `for` 문을 보면
```python
	for cellIdx in range(SIZE):
        if board[row][cellIdx] == num or board[cellIdx][col] == num:
            return False
```
`row`나 `col`은 입력을 받은 값에 대해 고정적으로 두고, `cellIdx`라는 인덱스를 `range`에 의하여 0번 인덱스부터 8번 인덱스까지 진행하여 그 행과 열에 대해 동시에 유효성 검사를 진행한다. `num`은 해당 빈칸을 채우려는 값이기 때문에 이 값과 같게 된다면 중복인 칸이 생긴다는 것이므로 `False`를 반환하여 나가면 된다.

두 번째 `for` 문을 보면
```python
    for r in range(BOX_SIZE):
        for c in range(BOX_SIZE):
            if num == board[row // BOX_SIZE * BOX_SIZE + r][col // BOX_SIZE * BOX_SIZE + c]:
                return False
```
여기에서 3×3 칸의 비교를 진행하는데, `r`과 `c`라는 값을 0~2 인덱스에서 지정하고, 해당 3×3 칸으로 돌기 위해 인덱스 계산을 진행해준다. 행이나 열 번호에 무관하게, 한 세트는 0~2 / 3~5 / 6~8의 형태가 된다. 그렇기 때문에 `row`나 `col`에 대하여 3으로 나눈 다음 3으로 곱하면, 0~2 인덱스의 경우 0이 되고, 3~5 인덱스의 경우 3, 6~8 인덱스의 경우 6이 된다. 그러니까 각 구역의 첫 번째 인덱스를 뽑아낼 수 있고 여기에 `r`이나 `c`의 값을 적절히 더해주면서 칸을 체크하면 되는 것이다. 이 역시 `num`과 같은 경우 `False`를 반환하면 된다.

모두 걸리지 않았다면 해당 칸에 `num`을 넣는 것이 유효성 검사를 통과한 것이므로 `True`를 반환한다.

## 정리
백트래킹을 사용하여 푸는 대표적인 문제이다. 스도쿠 칸을 적절히 체크하면서 넘어가야 하기 때문에, 인덱싱을 적절히 하는 것도 중요하며 규칙에 따라 열과 행 뿐만 아니라 3×3 크기의 정사각형 내에서 역시 유효성 검사를 제대로 하는 것이 중요한 문제였다.
